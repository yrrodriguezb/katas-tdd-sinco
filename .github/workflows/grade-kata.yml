name: Grade Kata

on:
  push:
    branches:
      - 'master'
      - 'main'
    paths:
      - 'katas/**'  # Solo ejecutar cuando hay cambios en carpetas de katas

permissions:
  contents: write
  pull-requests: write
  statuses: write
  issues: write

jobs:
  grade:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if katas exist
        id: check
        run: |
          # Verificar si existe alguna kata en el directorio katas/
          if [ -d "katas" ] && [ "$(ls -A katas 2>/dev/null)" ]; then
            echo "‚úÖ Katas directory exists and is not empty"
            echo "has_katas=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è  Katas directory is empty or doesn't exist - skipping workflow"
            echo "üí° This is normal for the initial commit from template"
            echo "has_katas=false" >> $GITHUB_OUTPUT
            exit 0
          fi

      - name: Setup .NET
        if: steps.check.outputs.has_katas == 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Get current kata
        if: steps.check.outputs.has_katas == 'true'
        id: kata
        run: |
          CURRENT=$(jq -r '.current_kata' .github/progress.json)
          echo "number=$CURRENT" >> $GITHUB_OUTPUT
          echo "üéØ Working on Kata $CURRENT"

      - name: Set commit status to pending
        if: steps.check.outputs.has_katas == 'true'
        run: |
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d '{
              "state": "pending",
              "description": "üß™ Running TDD tests...",
              "context": "kata-tests"
            }'

      - name: Run tests
        if: steps.check.outputs.has_katas == 'true'
        id: test
        run: |
          KATA_NUM=${{ steps.kata.outputs.number }}
          echo "üéØ Testing Kata $KATA_NUM with server tests..."
          
          # Verificar que existe la kata actual
          if [ ! -d "katas/kata-$KATA_NUM" ]; then
            echo "‚ùå Kata $KATA_NUM directory not found"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error_message=Kata directory not found" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # üîí DESCARGAR SERVER TESTS desde el template (seguridad)
          # Los server tests NO est√°n en el repo del estudiante para prevenir que vean las pruebas
          echo "üîê Descargando server tests desde template..."
          
          TEMPLATE_REPO="SincosoftSAS/tdd-katas-progressive-template"
          SERVER_TESTS_URL="https://raw.githubusercontent.com/$TEMPLATE_REPO/master/.github/server-tests/kata-$KATA_NUM/ServerTests.cs"
          
          mkdir -p ".github/server-tests/kata-$KATA_NUM"
          
          if ! curl -f -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
               -o ".github/server-tests/kata-$KATA_NUM/ServerTests.cs" \
               "$SERVER_TESTS_URL" 2>/dev/null; then
            echo "‚ùå Could not download server tests for kata-$KATA_NUM"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error_message=Server tests not found in template" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Server tests downloaded successfully"
          
          cd "katas/kata-$KATA_NUM"
          
          echo "üî® Building student solution..."
          if ! dotnet build --verbosity quiet > ../../build-output.txt 2>&1; then
            echo "‚ùå Build failed"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error_message=Build failed" >> $GITHUB_OUTPUT
            echo ""
            echo "üìã Build Error Details:"
            cat ../../build-output.txt
            exit 1
          fi
          
          echo "üß™ Running student tests (quick check)..."
          dotnet test --verbosity quiet --logger "console;verbosity=minimal" || echo "‚ÑπÔ∏è Student tests may fail (TDD process)"
          
          echo ""
          echo "üîç Running SERVER TESTS (comprehensive evaluation)..."
          
          # Crear directorio temporal para las pruebas del servidor
          cd ../../
          mkdir -p temp-server-tests
          
          # Copiar TODA la estructura del proyecto del estudiante
          cp -r "katas/kata-$KATA_NUM" "temp-server-tests/"
          
          cd "temp-server-tests/kata-$KATA_NUM"
          
          echo "üìã Original test files:"
          find . -name "*Tests.cs" -o -name "*Test.cs" | head -5
          
          # AGREGAR los archivos de server tests al proyecto como archivos adicionales
          # Esto permite ejecutar tanto los tests del estudiante como los del servidor
          
          SERVER_TEST_FILE="../../.github/server-tests/kata-$KATA_NUM/ServerTests.cs"
          if [ -f "$SERVER_TEST_FILE" ]; then
            echo "üîÑ Adding comprehensive server tests to project..."
            
            # Encontrar el directorio de tests del proyecto
            TEST_DIR=$(find . -name "*.Tests" -type d | head -1)
            if [ -n "$TEST_DIR" ]; then
              echo "  üìÅ Found test directory: $TEST_DIR"
              # Copiar el archivo de server tests al directorio de tests
              cp "$SERVER_TEST_FILE" "$TEST_DIR/ServerTests.cs"
              echo "  üìù Added ServerTests.cs with comprehensive server tests"
            else
              echo "  ‚ùå Could not find test directory"
              echo "result=failure" >> $GITHUB_OUTPUT
              echo "error_message=Test directory not found" >> $GITHUB_OUTPUT
              cd ../../
              rm -rf temp-server-tests
              exit 1
            fi
          else
            echo "  ‚ùå Server test file not found: $SERVER_TEST_FILE"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error_message=Server tests not found" >> $GITHUB_OUTPUT
            cd ../../
            rm -rf temp-server-tests
            exit 1
          fi
          
          echo ""
          echo "üìã After adding server tests - test files content:"
          find . -name "*Tests.cs" -not -path "*/obj/*" -not -path "*/bin/*" | while read testfile; do
            # Saltar archivos de template vac√≠os como UnitTest1.cs
            if [[ "$(basename "$testfile")" == "UnitTest1.cs" ]]; then
              echo "üìÑ $testfile: (skipping default template file)"
              continue
            fi
            
            echo "üìÑ $testfile:"
            # Contar tanto [Fact] (xUnit) como [TestMethod] (MSTest) para compatibilidad
            FACT_COUNT=$(grep -c "\[Fact\]" "$testfile" 2>/dev/null || echo "0")
            TESTMETHOD_COUNT=$(grep -c "\[TestMethod\]" "$testfile" 2>/dev/null || echo "0")
            
            # Asegurar que son n√∫meros v√°lidos
            if ! [[ "$FACT_COUNT" =~ ^[0-9]+$ ]]; then
              FACT_COUNT=0
            fi
            if ! [[ "$TESTMETHOD_COUNT" =~ ^[0-9]+$ ]]; then
              TESTMETHOD_COUNT=0
            fi
            
            TOTAL_TESTS=$((FACT_COUNT + TESTMETHOD_COUNT))
            echo "  xUnit [Fact] tests: $FACT_COUNT"
            echo "  MSTest [TestMethod] tests: $TESTMETHOD_COUNT" 
            echo "  Total test methods: $TOTAL_TESTS"
          done
          
          echo ""
          echo "üî® Building with server tests..."
          if ! dotnet build --verbosity normal > ../../server-build-output.txt 2>&1; then
            echo "‚ùå Build with server tests failed"
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "error_message=Server build failed" >> $GITHUB_OUTPUT
            echo ""
            echo "üìã Server Build Error Details:"
            cat ../../server-build-output.txt
            cd ../../
            rm -rf temp-server-tests
            exit 1
          fi
          
          echo ""
          echo "üß™ Executing SERVER TESTS..."
          # Ejecutar las pruebas del servidor (ahora incluidas como archivo adicional)
          if dotnet test --verbosity normal --logger "console;verbosity=detailed" > ../../server-test-output.txt 2>&1; then
            echo "‚úÖ ALL SERVER TESTS PASSED! Kata $KATA_NUM completed successfully"
            echo "result=success" >> $GITHUB_OUTPUT
            
            # Mostrar resumen completo
            echo ""
            echo "üìä Complete Test Results Summary:"
            cat ../../server-test-output.txt | grep -E "(Passed|Failed|Skipped|Total)" || echo "Could not parse results"
            
            # Contar tests ejecutados
            TOTAL_TESTS=$(cat ../../server-test-output.txt | grep -o "Passed.*" | wc -l)
            echo ""
            echo "üéØ Total server tests executed: $TOTAL_TESTS"
            
          else
            echo "‚ùå SERVER TESTS FAILED - Kata $KATA_NUM not yet complete"
            echo "result=failure" >> $GITHUB_OUTPUT

            echo ""
            echo "üìã Detailed server test failure report:"
            cat ../../server-test-output.txt

            echo ""
            echo "üîç Extracting specific failed test information..."

            # Extraer informaci√≥n de tests fallidos con nombres y errores espec√≠ficos
            echo "üìã Processing test failures..."

            # Crear archivo temporal con toda la informaci√≥n de fallos
            cat ../../server-test-output.txt > ../../full-test-output.txt

            # Inicializar archivo de fallos
            echo "" > ../../structured-failures.txt

            # Extraer tests fallidos usando un enfoque m√°s directo
            echo "üîç Searching for failed tests..."

            # Buscar l√≠neas que contienen FAIL o Failed y extraer nombres de tests
            grep -E "FAIL|Failed" ../../full-test-output.txt | while IFS= read -r line; do
              echo "Processing line: $line" >&2
              
              # Extraer nombre del test de diferentes patrones
              if [[ "$line" =~ ServerTests\.([A-Za-z_][A-Za-z0-9_]*) ]]; then
                # Patr√≥n: FAIL ServerTests.Generate_WithOne_ReturnsListWithOne
                RAW_NAME=$(echo "$line" | grep -o 'ServerTests\.[A-Za-z_][A-Za-z0-9_]*' | sed 's/ServerTests\.//')
                CLEAN_NAME=$(echo "$RAW_NAME" | sed 's/_/ /g')
                echo "‚ùå $CLEAN_NAME" >> ../../structured-failures.txt
                echo "Found test: $CLEAN_NAME" >&2
              elif [[ "$line" =~ Tests\.([A-Za-z_][A-Za-z0-9_]*) ]]; then
                # Patr√≥n: FAIL FizzBuzz.Tests.Generate_WithOne_ReturnsListWithOne
                RAW_NAME=$(echo "$line" | grep -o 'Tests\.[A-Za-z_][A-Za-z0-9_]*' | sed 's/Tests\.//')
                CLEAN_NAME=$(echo "$RAW_NAME" | sed 's/_/ /g')
                echo "‚ùå $CLEAN_NAME" >> ../../structured-failures.txt
                echo "Found test: $CLEAN_NAME" >&2
              elif [[ "$line" =~ Failed\ ([A-Za-z_][A-Za-z0-9_]*) ]]; then
                # Patr√≥n: Failed Generate_WithOne_ReturnsListWithOne
                RAW_NAME=$(echo "$line" | grep -o 'Failed [A-Za-z_][A-Za-z0-9_]*' | sed 's/Failed //')
                CLEAN_NAME=$(echo "$RAW_NAME" | sed 's/_/ /g')
                echo "‚ùå $CLEAN_NAME" >> ../../structured-failures.txt
                echo "Found test: $CLEAN_NAME" >&2
              fi
            done
            
            # Verificar si encontramos tests fallidos
            if [ -f "../../structured-failures.txt" ] && [ -s "../../structured-failures.txt" ]; then
              # Limpiar y deduplicar
              sort -u ../../structured-failures.txt > ../../failed-test-details.txt
              FOUND_TESTS=$(cat ../../failed-test-details.txt)
              echo "üìù Failed tests identified:"
              echo "$FOUND_TESTS"
            else
              echo "‚ö†Ô∏è No failed tests found with structured approach, trying alternative..."
              
              # M√©todo alternativo: buscar cualquier l√≠nea con "FAIL" y extraer lo que sigue
              grep -o "FAIL.*" ../../full-test-output.txt | head -10 | while IFS= read -r fail_line; do
                # Extraer la parte m√°s probable del nombre del test
                if [[ "$fail_line" =~ ([A-Za-z_][A-Za-z0-9_]{5,}) ]]; then
                  RAW_NAME="${BASH_REMATCH[1]}"
                  CLEAN_NAME=$(echo "$RAW_NAME" | sed 's/_/ /g')
                  echo "‚ùå $CLEAN_NAME" >> ../../failed-test-details.txt
                fi
              done
              
              if [ ! -f "../../failed-test-details.txt" ] || [ ! -s "../../failed-test-details.txt" ]; then
                echo "‚ùå Algunas pruebas fallaron (ejecuta 'dotnet test' localmente para ver detalles)" > ../../failed-test-details.txt
              fi
            fi
            
            echo ""
            echo "üí° Keep implementing using TDD until all functionality is complete!"
            echo "üìù Server tests are comprehensive and test ALL required features."

            # Guardar la informaci√≥n de tests fallidos en el output del step
            if [ -f "../../failed-test-details.txt" ]; then
              FAILED_TESTS_CONTENT=$(cat ../../failed-test-details.txt)
              # Usar delimitador EOF para contenido multil√≠nea
              echo "failed_tests_details<<EOF" >> $GITHUB_OUTPUT
              echo "$FAILED_TESTS_CONTENT" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT

              # Tambi√©n imprimir en formato especial para que el webhook pueda extraerlo
              echo ""
              echo "::group::üìù Failed tests identified:"
              echo "$FAILED_TESTS_CONTENT"
              echo "::endgroup::"

              # Guardar en el job summary para que sea accesible desde la API
              echo "## üìù Failed Tests" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "$FAILED_TESTS_CONTENT" >> $GITHUB_STEP_SUMMARY
            else
              echo "failed_tests_details=‚ùå No se pudieron extraer detalles de tests fallidos" >> $GITHUB_OUTPUT
            fi

            # Limpiar y salir con error
            cd ../../
            rm -rf temp-server-tests
            exit 1
          fi
          
          # Limpiar (solo si fue exitoso)
          cd ../../
          rm -rf temp-server-tests

      - name: Update progress on success
        if: steps.check.outputs.has_katas == 'true' && steps.test.outputs.result == 'success'
        run: |
          CURRENT=${{ steps.kata.outputs.number }}
          NEXT=$((CURRENT + 1))
          
          # Update progress.json
          jq ".current_kata = $NEXT | .completed_katas += [$CURRENT] | .last_updated = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" .github/progress.json > temp.json
          mv temp.json .github/progress.json
          
          # Commit changes
          git config user.name "TDD Bot"
          git config user.email "tdd-bot@github.com"
          git add .github/progress.json
          git commit -m "Complete Kata $CURRENT" || true
          git push origin ${{ github.ref_name }}
          
          echo "üìä Progress updated: Kata $CURRENT ‚Üí Kata $NEXT"

      - name: Close resolved issues
        if: steps.check.outputs.has_katas == 'true' && steps.test.outputs.result == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          KATA_NUM=${{ steps.kata.outputs.number }}
          echo "üîç Buscando issues abiertos para Kata $KATA_NUM..."
          
          # Buscar y cerrar todos los issues abiertos relacionados con esta kata
          ISSUE_NUMBERS=$(gh issue list --repo ${{ github.repository }} \
            --state open \
            --search "Kata $KATA_NUM in:title" \
            --json number \
            --jq '.[].number' 2>/dev/null || echo "")
          
          if [ -n "$ISSUE_NUMBERS" ]; then
            echo "‚úÖ Cerrando issues resueltos..."
            echo "$ISSUE_NUMBERS" | while read -r issue_num; do
              if [ -n "$issue_num" ]; then
                echo "Cerrando issue #$issue_num..."
                gh issue close "$issue_num" \
                  --repo ${{ github.repository }} \
                  --comment "‚úÖ **Problema Resuelto** - Todas las pruebas ahora pasan correctamente."$'\n\n'"üéâ **¬°Excelente trabajo!** Has completado exitosamente la Kata $KATA_NUM."$'\n\n'"üìà **Siguiente paso:** Contin√∫a con la siguiente kata para seguir mejorando tus habilidades de TDD." \
                  2>/dev/null || echo "‚ö†Ô∏è No se pudo cerrar issue #$issue_num"
              fi
            done
            echo "‚ú® Issues cerrados exitosamente"
          else
            echo "‚ÑπÔ∏è No hay issues abiertos para cerrar"
          fi

      - name: Unlock next kata
        if: steps.check.outputs.has_katas == 'true' && steps.test.outputs.result == 'success'
        run: |
          CURRENT=${{ steps.kata.outputs.number }}
          NEXT=$((CURRENT + 1))

          # Usar kata-templates locales (actualizados por sync-to-students)
          if [ -d ".github/kata-templates/kata-$NEXT" ] && [ ! -d "katas/kata-$NEXT" ]; then
            echo "üîì Unlocking Kata $NEXT..."

            # Copy template to working directory
            cp -r ".github/kata-templates/kata-$NEXT" "katas/"

            # Commit new kata
            git add "katas/kata-$NEXT"
            git commit -m "üîì Unlock Kata $NEXT" || true
            git push origin ${{ github.ref_name }}

            echo "‚úÖ Kata $NEXT unlocked!"
          else
            echo "üèÜ All katas completed or next kata already exists!"
          fi

      - name: Close old issues from previous katas
        if: steps.check.outputs.has_katas == 'true' && steps.test.outputs.result == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CURRENT=${{ steps.kata.outputs.number }}
          echo "üßπ Limpiando issues antiguos de katas anteriores..."
          
          # Cerrar issues de katas anteriores (1 a CURRENT-1)
          for prev_kata in $(seq 1 $((CURRENT - 1))); do
            echo "Buscando issues de Kata $prev_kata..."
            
            PREV_ISSUES=$(gh issue list --repo ${{ github.repository }} \
              --state open \
              --search "Kata $prev_kata in:title" \
              --json number \
              --jq '.[].number' 2>/dev/null || echo "")
            
            if [ -n "$PREV_ISSUES" ]; then
              echo "$PREV_ISSUES" | while read -r issue_num; do
                if [ -n "$issue_num" ]; then
                  echo "Cerrando issue antiguo #$issue_num de Kata $prev_kata..."
                  gh issue close "$issue_num" \
                    --repo ${{ github.repository }} \
                    --comment "üìà **Kata Superada** - Has avanzado exitosamente a la Kata $CURRENT."$'\n\n'"Este issue se cierra autom√°ticamente ya que pertenece a una kata anterior que ya completaste."$'\n\n'"¬°Sigue adelante con tu aprendizaje de TDD! üöÄ" \
                    2>/dev/null || echo "‚ö†Ô∏è No se pudo cerrar issue #$issue_num"
                fi
              done
            fi
          done
          
          echo "‚ú® Limpieza de issues completada"

      - name: Set final commit status
        if: always() && steps.check.outputs.has_katas == 'true'
        run: |
          if [ "${{ steps.test.outputs.result }}" == "success" ]; then
            STATE="success"
            DESC="‚úÖ Tests passed! Kata ${{ steps.kata.outputs.number }} completed"
          else
            STATE="failure"  
            DESC="‚ùå Tests failed - check logs for details"
          fi
          
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/statuses/${{ github.sha }}" \
            -d "{
              \"state\": \"$STATE\",
              \"description\": \"$DESC\",
              \"context\": \"kata-tests\",
              \"target_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
            }"

      - name: Create failure issue
        if: steps.check.outputs.has_katas == 'true' && steps.test.outputs.result == 'failure'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          KATA_NUM=${{ steps.kata.outputs.number }}
          ERROR_MSG="${{ steps.test.outputs.error_message }}"
          
          # Verificar configuraci√≥n de GitHub CLI
          echo "üîç Checking GitHub CLI configuration..."
          gh --version
          gh auth status || echo "Auth status check failed"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          
          # Funci√≥n para crear issue con manejo robusto de errores
          create_issue_safe() {
            local title="$1"
            local body="$2"
            
            echo "Creating issue: $title"
            echo "Body preview: ${body:0:100}..."
            
            # Escapar caracteres especiales en el t√≠tulo y cuerpo
            local safe_title=$(echo "$title" | sed 's/"/\\"/g')
            local safe_body=$(echo "$body" | sed 's/"/\\"/g' | tr '\n' ' ')
            
            # Intentar crear issue paso a paso para debugging
            echo "Attempting to create issue with gh CLI..."
            
            # Primer intento: con asignaci√≥n (sin labels problem√°ticos)
            if gh issue create \
              --title "$safe_title" \
              --body "$safe_body" \
              --assignee "${{ github.actor }}" 2>&1; then
              echo "‚úÖ Issue created and assigned successfully"
              return 0
            fi
            
            echo "Assignment failed, trying without assignee..."
            
            # Segundo intento: sin asignaci√≥n
            if gh issue create \
              --title "$safe_title" \
              --body "$safe_body" 2>&1; then
              echo "‚úÖ Issue created successfully (without assignee)"
              return 0
            fi
            
            echo "Both attempts failed, trying with minimal content..."
            
            # Tercer intento: versi√≥n simplificada
            if gh issue create \
              --title "Kata $KATA_NUM: Pruebas Fallaron" \
              --body "Las pruebas fallaron. Ejecuta 'dotnet test' en katas/kata-$KATA_NUM para ver los detalles espec√≠ficos de los errores y contin√∫a con la implementaci√≥n TDD." 2>&1; then
              echo "‚úÖ Minimal issue created successfully"
              return 0
            fi
            
            echo "‚ùå All attempts to create issue failed"
            return 1
          }
          
          # Crear issue espec√≠fico basado en el tipo de error
          if [[ "$ERROR_MSG" == *"Build failed"* ]]; then
            ISSUE_BODY="üî® **Error de Compilaci√≥n** - Tu c√≥digo no compila."$'\n\n'"**Pasos a seguir:**"$'\n'"1. Ejecuta \`dotnet build\` en \`katas/kata-$KATA_NUM\` para ver los errores de compilaci√≥n"$'\n'"2. Corrige los errores de compilaci√≥n en tu c√≥digo"$'\n'"3. Haz commit y push de tus cambios para reintentar"
            create_issue_safe "üî® Kata $KATA_NUM: Error de Compilaci√≥n" "$ISSUE_BODY"
              
          elif [[ "$ERROR_MSG" == *"Server build failed"* ]]; then
            ISSUE_BODY="‚öôÔ∏è **Error de Integraci√≥n del Servidor** - Tu c√≥digo compila pero hay un problema con la integraci√≥n de las pruebas del servidor."$'\n\n'"**Posibles Causas:**"$'\n'"- Error en el namespace"$'\n'"- El nombre de la clase no coincide con el formato esperado"$'\n'"- Faltan modificadores de acceso p√∫blico"$'\n\n'"**Pasos a seguir:**"$'\n'"1. Verifica que tus namespaces y nombres de clase coincidan con el formato esperado"$'\n'"2. Aseg√∫rate de que tus clases principales sean p√∫blicas"$'\n'"3. Haz commit y push de tus cambios para reintentar"
            create_issue_safe "‚öôÔ∏è Kata $KATA_NUM: Error de Integraci√≥n" "$ISSUE_BODY"
              
          else
            # Server tests failed - crear issue con detalles
            echo "Creating detailed test failure issue..."
            
            # Extraer mensajes de error espec√≠ficos estructurados
            FORMATTED_ERROR_MESSAGES=""
            FAILED_INFO="Some tests failed"
            
            echo "üìã Reading extracted test failures..."
            
            if [ -f "failed-test-details.txt" ]; then
              DETAILED_ERROR_CONTENT=$(cat failed-test-details.txt 2>/dev/null || echo "")
              echo "Content found: $DETAILED_ERROR_CONTENT"
              
              if [ -n "$DETAILED_ERROR_CONTENT" ] && [ "$DETAILED_ERROR_CONTENT" != "Could not extract test failure details" ]; then
                # Formatear los mensajes para el issue (cada prueba en su l√≠nea)
                FORMATTED_ERROR_MESSAGES=$(echo "$DETAILED_ERROR_CONTENT" | head -10)
                FAILED_COUNT=$(echo "$DETAILED_ERROR_CONTENT" | wc -l || echo "1")
                FAILED_INFO="$FAILED_COUNT pruebas fallaron"
                echo "üìù Formatted error messages: $FORMATTED_ERROR_MESSAGES"
              else
                echo "‚ö†Ô∏è Content is empty or invalid"
                FORMATTED_ERROR_MESSAGES="Las pruebas fallaron pero no se pudieron extraer detalles espec√≠ficos"
              fi
            else
              echo "‚ö†Ô∏è failed-test-details.txt not found"
              FORMATTED_ERROR_MESSAGES="Las pruebas fallaron pero no se pudieron extraer detalles espec√≠ficos"
            fi
            
            # Si a√∫n no encontramos errores espec√≠ficos, usar informaci√≥n general mejorada
            if [ -z "$FORMATTED_ERROR_MESSAGES" ]; then
              FORMATTED_ERROR_MESSAGES="‚ùå No se pudieron extraer los nombres espec√≠ficos de las pruebas"$'\n'"‚ùå Ejecuta \`dotnet test\` en \`katas/kata-$KATA_NUM\` para ver qu√© pruebas espec√≠ficas est√°n fallando"
              FAILED_INFO="Pruebas fallaron - revisa localmente para m√°s detalles"
            fi
            
            # Crear mensaje detallado del issue usando concatenaci√≥n con saltos de l√≠nea reales
            ISSUE_BODY="üß™ **Pruebas del Servidor Fallaron** - Tu kata a√∫n no est√° completa."$'\n\n'"**Estado:** El c√≥digo compila exitosamente pero falta alguna funcionalidad."$'\n\n'"**Pruebas que Fallaron:**"$'\n'"$FORMATTED_ERROR_MESSAGES"$'\n\n'"**Pasos a seguir:**"$'\n'"1. Analiza los mensajes de error de arriba para entender qu√© se espera"$'\n'"2. Implementa la funcionalidad faltante para corregir estos problemas espec√≠ficos"$'\n'"3. Usa el enfoque TDD: haz que una prueba pase a la vez"$'\n'"4. Haz commit y push de tus cambios para reintentar"
            
            create_issue_safe "üß™ Kata $KATA_NUM: Pruebas Fallaron" "$ISSUE_BODY"
          fi